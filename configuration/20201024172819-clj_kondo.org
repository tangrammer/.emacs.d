clojure
[[file:20201024172354-coding.org][coding]]


if you have any problem with it you should take a look to
(find-function 'org-babel-execute:clojure)


** clj-kondo
https://github.com/borkdude/clj-kondo
download binary
install emacs package flycheck-clj-kondo

#+BEGIN_SRC shell  :results silent
curl -sLO https://raw.githubusercontent.com/borkdude/clj-kondo/master/script/install-clj-kondo
chmod +x install-clj-kondo
./install-clj-kondo

#+END_SRC



 #+RESULTS:
 | Downloading  | https://github.com/borkdude/clj-kondo/releases/download/v2020.11.07/clj-kondo-2020.11.07-macos-amd64.zip | to        | /tmp |                |
 | Successfully | installed                                                                                                | clj-kondo | in   | /usr/local/bin |

#+BEGIN_SRC emacs-lisp :results silent
(use-package flycheck-clj-kondo
:straight t
  )
(require 'flycheck-clj-kondo)

#+END_SRC

;; First install the package:

;; then install the checker as soon as `clojure-mode' is loaded

** cider

 #+BEGIN_SRC emacs-lisp :results silent
   ;;  make autoloads ;; do that in terminal and... it requires to have installed `cask`


 (use-package cider
   :straight t)

 (use-package clojure-mode
   :straight t
   :config
   (require 'flycheck-clj-kondo))






    (add-to-list 'load-path "~/git/tangrammer/sesman") ;; boths locally cloned



   ;;; https://cider.readthedocs.io/en/latest/hacking_on_cider/#obtaining-the-source-code

   ;; (add-to-list 'load-path "~/git/tangrammer/cider")

   ;; (require 'cider)
   ;; (require 'cider-autoloads)

    (org-defkey org-mode-map "\C-x\C-e" 'cider-eval-last-sexp)
    (org-defkey org-mode-map "\C-c\C-d" 'cider-doc)
    (org-defkey org-mode-map "\C-c\M-j" 'cider-jack-in)

    ;; Show documentation/information with M-RET
    (define-key lisp-mode-shared-map (kbd "M-RET") 'live-lisp-describe-thing-at-point)
  ;;  (define-key cider-repl-mode-map (kbd "M-RET") 'cider-doc)
  ;;  (define-key cider-mode-map (kbd "M-RET") 'cider-doc)


    ;; clojure figwheel
    ;; https://github.com/bhauman/lein-figwheel/wiki/Running-figwheel-with-Emacs-Inferior-Clojure-Interaction-Mode
    ;; (defun figwheel-repl ()
    ;;   (interactive)
    ;;   (run-clojure "lein figwheel"))

    ;;(add-hook 'clojure-mode-hook #'inf-clojure-minor-mode)

  ;;  (define-key cider-repl-mode-map (kbd "C-c C-o") 'cider-repl-clear-output)


    ;; https://github.com/stuartsierra/component/issues/55
    ;; emacs, init.el

    ;; find all buffers names which match `reg`, regex
    (defun find-buffer-regex (reg)
      (interactive)
      (remove-if-not #'(lambda (x) (string-match reg x))
         (mapcar #'buffer-name (buffer-list))))

    (defun cider-execute (command)
      (interactive)
      (set-buffer (car (find-buffer-regex "cider-repl.*")))
      (goto-char (point-max))
      (insert command)
      (cider-repl-return))

    (defun nrepl-reset ()
      (interactive)
      (cider-execute "(clojure.tools.namespace.repl/refresh)"))

  ;;  (define-key cider-mode-map (kbd "C-c r") 'nrepl-reset)

  ;;  (define-key cider-repl-mode-map (kbd "C-c r") 'nrepl-reset)

    (defun nrepl-test ()
      (interactive)
      (nrepl-reset)
      (cider-execute "(duct.util.repl/test)"))
  ;;  (define-key cider-mode-map (kbd "C-c t") 'nrepl-test)


    (setq cider-cljs-lein-repl
    "(do (require 'figwheel-sidecar.repl-api)
     (figwheel-sidecar.repl-api/start-figwheel!)
     (figwheel-sidecar.repl-api/cljs-repl))")


    (setq nrepl-log-messages t)

    (setq cider-repl-scroll-on-output nil)
    (setq cider-show-eval-spinner nil)


    ;; (let ((resp (cider-nrepl-sync-request:eval "(+ 1 1)")))
    ;;    (nrepl-dict-get resp "value"))


    (defun browse-spec (spec)
      (interactive (list (cider-symbol-at-point)) )
      (let ((last-sexp (nrepl-dict-get (cider-nrepl-sync-request:eval (cider-symbol-at-point)) "value")))
        (cider-browse-spec last-sexp)))

  ;;  (define-key cider-mode-map (kbd "<M-S-return>") 'browse-spec)



 #+END_SRC


add [[file:20201106210428-paredit_mode.org][paredit mode]]
#+BEGIN_SRC emacs-lisp :results silent
 (add-hook 'cider-repl-mode-hook #'paredit-mode)
 (add-hook 'cider-mode-hook #'paredit-mode)

#+END_SRC



** hola
*** TODO eval pprint replace                                          :cider:
  firstly sort clojure maps https://github.com/bluekezza/clj-stable-pprint
 ~[clj-stable-pprint "0.0.3"]~
 then connect cider with clj-stable-pprint and set up a shortcut command

** lumen

added https://github.com/bluekezza/clj-stable-pprint to get pprint map data sorted

modified [[/Users/tangrammer/git/tangrammer/cider/cider-client.el::228][cider-client.el]]

 #+BEGIN_SRC emacs-lisp :results silent
 (defun connect-lument-repl ()
   (interactive)
   ;;(cider-connect  "47480" "~/git/akvo/akvo-lumen/backend")
   (cider-nrepl-connect
    (list :host "localhost" :port "47480"
	  :repl-type "clj"
	  :repl-init-function nil
	  :session-name nil
	  :project-dir "~/git/akvo/akvo-lumen/backend"))

   (cider-interactive-eval "(require '[clj-stable-pprint.core :as spp])"))

 (define-key global-map (kbd "C-c l") 'connect-lument-repl)
#+END_SRC

 #+RESULTS:

** hugslq
#+BEGIN_SRC emacs-lisp :results silent
;; https://github.com/rkaercher/hugsql-ghosts
;; (require 'hugsql-ghosts)

;; (add-hook 'cider-mode-hook 'hugsql-ghosts-install-hook)

#+END_SRC


** pprint to file commented
#+BEGIN_SRC emacs-lisp :results silent
(defun pprint ()
 (interactive)
 (cider-pprint-eval-last-sexp-to-comment))

;;(define-key cider-mode-map (kbd "C-c C-S-p") 'pprint)
;;(define-key cider-mode-map (kbd "C-c C-p") 'cider-pprint-eval-last-sexp)

#+END_SRC
